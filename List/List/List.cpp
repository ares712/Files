#include <iostream>
#include <list> // 리스트 사용 기능

using namespace std;

// List : 불연속적 자료에 상관관계를 부여하여 구축한 자료 구조
//        (아무 데나 있는 자료에 순번을 매긴 동적 배열)

int main()
{
    // 리스트
    list<int> intList; // 리스트 선언 방법

    for (int i = 0; i < 10; ++i)
    {
        intList.push_back(i + 1); //1부터 10까지
    }

    // 리스트 출력
    // list는 반복자를 써서 값에 접근해야 한다
    list<int>::iterator iter = intList.begin(); // 벡터와 똑같이 선언 및 초기화한다

    for (int i = 0; i < 10; ++i)
    {
        iter = intList.begin(); // 작은 반복문 시작 전마다 반복자 리셋

        //반복자를 조작하기 위한 반복문 (해당 차례가 올 때까지 반복자를 증가시키기 위함)
        for (int j = 0; j < i; ++j)
        {
            iter++;
        }

        std::cout << *iter << std::endl; // iter의 값 호출
    }

    // []도 쓸 수 없는 불편한 list가 쓰이는 이유
    // 메모리 효율과 삽입, 삭제의 빠른 속도 때문에
    // (메모리가 불연속적이므로 사본에 집착할 필요가 없다)

    // 벡터와 리스트 중에서 언제, 어느 쪽이 더 효율적인가?

    // 리스트 : 자료의 삽입, 추가, 삭제가 매우 빠르다.
    //         사본 형성을 잘 안 해서 메모리 효율도 높다

    //         -> 따라서 수정이 자주 일어나는 데이터 관리에 써먹으면 좋다
    //            (이를테면 대화 로그, MMORPG 등에서 플레이어 스킬북(스킬 포인트 창 아님))

    //          반면, 참조가 느리다, 연산 코드 짜기도 번거롭다
    //          -> 자주 열고 봐야 되는 데이터를 리스트로 만들면 귀찮을지도
    //             (이를테면 인벤토리, 스킬 포인트 분배, 파티 구성창 등)

    // 벡터 : 삽입, 추가, 삭제 시에 클래스 내부에서 연산이 복잡하다 (=느리다)
    //        메모리 효율이 다소 좋지 못하다.

    //        -> 자주 수정이 일어나는 데이터 관리에는 최적의 선택은 아니다

    //        반면 한 번 만들어진 배열을 다시 참조하는 건 매우 빠르다
    //        -> 자주 배열을 참조해야 할 때 벡터를 쓰면 좋다
    //        -> 특히 크기가 변해야 하면 (인스턴스 파티 등) 벡터는 필수
}