#include "MyClass.h"

int main()
{
    // 여기서는 클래스를 호출하고 사용하고 수정한다

    // 클래스도 구조체처럼 그 자체가 진짜 데이터가 아니다
    // 말하자면 설계도, 혹은 DNA, "특성과 성격"

    // 클래스가 프로그램에 나오려면 변수 혹은 구조체처럼
    // 선언 및 초기화가 되어야 한다

    MyClass mcs; // 이렇게 선언해야 사용 가능

    // 그런데 이렇게 선언된 "데이터"를 지칭할 때, 변수는 당연히 변수라고 불렀다
    // 구조체는 구조체 변수, 포인터는 포인터 변수, 배열은 배열이지만,
    // 배열이란 이름 안에 "변수의 집합"과 "포인터"라는 뜻이 다 들어가 있다

    // 반면 클래스는? 안에 변수가 있긴 하지만, 클래스는 변수가 아니라 그 이상
    // 함수인가? 함수도 아니고 그 이상 -> 그 모든 것의 종합

    // 그래서 클래스를 선언한 "데이터"는 변수라고 부르지 않고, "생성된 존재"라고 부른다

    // 다른 용어로는 "인스턴스"(instance)

    // 그리고 인스턴스의 원본인 클래스와, 다시 그 클래스로 만들어낸 인스턴스
    // 이 둘을 총칭해서 "객체"라고 한다 (오브젝트)

    // 인스턴스 사용 방법

    cout << "mcs.x : " << mcs.x << endl; // 변수 호출
    cout << "mcs.Multi(10. 5) : " << mcs.Multi(10, 5) << endl;// 함수 호출

    // 구조체에서 변수를 쓰는 것처럼 인스턴스에서 함수도 불러낼 수 있다

    // 주의할 점 : public만 호출 가능 (private는 호출 불가)

    // 다시 말해, 클래스는 (이전까지의 문법과 달리) private 밑에 코드를 작성함으로써
    // 밖에서 해당 데이터를 (변수든 함수든) 호출도 수정도 아예 불가능하게 할 수 있다

    // 이렇게 함으로써 1. 자기 안의 데이터를 안전하게 지킬 수도 있고
    // (예 : 굳이 상수를 고집하지 않고도 id를 아무도 수정 못하게 할 수 있음)
    // 2. 쓰는 입장에서 골치 아프게 고민하면서 "쓸까 말까"를 판단할 필요도 없어진다
    // (안 보이는 데이터? 고치면 안 되니까 그랬겠지. 데이터가 보인다? 써도 되겠지)

    // 이렇게 해서 데이터를 안전하게 숨김과 동시에 편리하게 노출을 축소시키는 것
    // -> 은닉(은닉성, data hiding) / 밀폐, 캡슐화(encapsulation)

    // 클래스와 인스턴스, 즉 은닉이 있는 개체에서 은닉된 정보를 어떻게 활용하는가

    // 1. 제일 쉽고 제일 정확한 활용법 : 안 쓴다.
    // 2. 그래도 쓰겠다면 : 호출 전용 함수를 public에 하나 더 만든다

    // 2-1. 변수에도 비슷한 식으로 호출 전용 함수를 public에 만들어두면,
    // 수정은 할 수 없고 볼 수만 있는 (마치 상수처럼 쓰는) 데이터를 만들 수 있다

    // (클래스 헤더 참조)
    cout << mcs.ID() << endl; // 함수로써 호출만(그리고 열람만)


    // 3. (사실 현역들이 무진장 비추하는 방법. 그러나 본인들도 잘만 쓴다)
    //    수정 전용 함수도 따로 하나 더 만들면 된다
    mcs.SetID(1999);
    cout << "mcs.ID() : " << mcs.ID() << endl;

    // 은닉을 했다고 하더라도 쓰다 보면 데이터 수정 욕구가 생기는 게 개발자
    // -> 이렇게 수정용 함수를 쓰게 되면 데이터 접근권은 매우 커진다

    // 이 때
    // 수정 전용 함수를 세터(Set~~)로 
    // 열람 전용 함수를 게터(Get~~)로 부른다

    // 비추하는 이유 : 수정도 되고 열람도 되는데 private에 코드 쓸 의미가 없다고 여기는 것

    // 클래스 데이터 활용 간단 팁

    // "이니시에이터"
    // public으로 작성, 자유 호출 가능
    // 꼭 필요한 경우(처음 만들어진 경우)가 아니라면 잘 호출하지 않게 된다

    // 이니시에이터의 목적 : 그 클래스의 모든 변수 값을 한번에 할당하는 것
    // 모든 변수에 대응하는 매개변수를 한 번에 받기도 한다
    // 보안상 위험하지만, 만들면 오용은 덜 되는 함수

    // 이니시에이터 작성 후 호출
    mcs.Init(100, 200, 300, 2000); // 값을 새로 지정

    cout << mcs.ID() << endl;
    cout << mcs.Multi(20, 8) << endl;
    
    // 이렇게 이니시에이터를 만들면 다른 문법을 쓰지 않아도 같은 클래스에서
    // 다른 인스턴스를 만들었을 때 서로 값을 다르게 줄 수 있다.

    MyClass mcs2;
    mcs2.Init(10, 20, 30, 200);

    cout << mcs2.ID() << endl;
    cout << mcs2.Multi(20, 8) << endl;

    // 다만 이니시에이터 역시 결국은 보안에 문제가 있다는 게 바뀌진 않아서,
    // private이 좀 더 보호받을 수 있는 다른 문법이 같이 사용될 경우,
    // 해당 문법과 짝을 이루어서 더 안전하게 실행되도록 코딩되는 경향이 있다

    // =================================================================

    // 생성자를 이용하기
    constructorClass ctClass(1, 300, 20, 150); // 멤버 이니셜라이저 사용
    // 위처럼 () 안에 매개변수를 넣어서 변수를 할당하고 인스턴스 생성 가능

    // 생성자에 매개변수를 안쓰면 인스턴스 생성은 가능한가?
    // constructorClass ctClass2; >> 이렇게는 사용가능
    // constructorClass ctClass3(); >> 이렇게는 사용 불가하다

    // 생성자를 선언에 사용할 때 매개변수 없이 ()를 쓰면 컴퓨터가 "매개변수를 안 줬다"고 생각해서 오류를 일으킴
    // -> 생성자는 작성도 조금 특이하지만, 호출도 약간 다른 함수와는 다르다
    // -> 생성자에 매개변수가 없거나 쓰기 싫을 때는 그냥 ()까지 다 떼고 ;을 붙이면 된다
    // -> 이럴 때 생성되는, 매개변수가 지정되지 않은 생성자를 기본 생성자라고 한다

    //생성자를 작성할 때, 멤버 이니셜라이저를 사용하면 더 정확하고 빠른 코딩 가능
    // 반면 생성자 초기화는 개발자의 의도를 모두와 쉽게 공유 가능

    // 마찬가지로 인스턴스를 만들 때도, 편하게 만드는 방법 외에
    // (컴퓨터를 낭비하면서) 값을 안전하게 복사해서 만드는 방법,
    // (약간 숙달이 늦지만) 안전하면서 동시에 빠르고 편하게 만드는 방법 존재

    // 예시 전용 인스턴스들
    constructorClass ctClass3(0, 0, 0, 0); // 기본적인 생성 방법 (쉽고 편하다)
    // 메모리에 그대로 값을 넣는 방법이라 다소 불안하고 느리다

    constructorClass ctClass4 = *new constructorClass(0, 0, 0, 0); // 값 복사 생성
    // 다른 메모리 영역에서 임시 인스턴스를 쓰고, 그 값을 복사해오기
    // 데이터의 안전이란 측면에서는 안전하다는 것이 장점

}