#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> vec;

    vec.push_back(0);
    vec.push_back(1);
    vec.push_back(2);


    // 벡터가 터지는 걸 막으려면 :
    // 애초에 벡터의 크기를 잘 계산해서 함부로 넘지 않도록 조심
    // (그 과정에서 벡터.size() 함수가 빈번히 쓰인다)
    // 벡터의 메모리 위치 등의 데이터를 아는 것도 좋을지도

    // -> 그래서 벡터의 메모리 위치를 알려면 다른 특별한 방법을 써야 한다

    // 다행히 C++에서는 벡터에서 메모리 위치를 알게 해주는 전용 기능이 있다

    // 그 기능의 이름은 "반복자"라고 한다 (iterator, "순찰자")

    // 반복자의 사용
    vector<int>::iterator it = vec.begin();

    // 출력
    std::cout << *it << std::endl;

    // 반복자의 데이터 의미는 벡터의 메모리 "정보" (위치 + @)
    // 그렇기 때문에 바로 출력은 못 하지만, 값은 호출할 수 있다

    // ++, -- 연산 가능
    it++; // 이 코드 한번마다 순번이 1씩 올라간다
    it++;
    
    std::cout << *it << std::endl;

    // 이렇게 반복자의 존재와 사용 방법을 응용하면
    for (vector<int>::iterator it2 = vec.begin();
        it2 != vec.end();
        it2++)
    {
        std::cout << *it2 << std::endl; // 이렇게도 벡터 출력 가능
    }

    // 반복자의 응용
    it = vec.begin(); // 반복자 순번을 0번으로

    vec.insert(it, 300); // vec.begin() 대신 it를 사용할 수 있다

    /*
    it = vec.begin(); //순번 0으로 맞추고

    it++;
    it++; //순번 + 2

    vec.insert(it, 99999); //삽입 한 번 해주고

    it++;
    it++;
    it++; //순번 + 3

    vec.insert(it, 99999); //삽입 두 번 해주고

    //출력
    for (std::vector<int>::iterator it2 = vec.begin();
        it2 != vec.end(); it2++)
    {
        std::cout << *it2 << std::endl;
    }
    */

    // 위처럼 작성하면 코드상 문제가 없는데도 실행하면 앱이 중단된다
    // 왜?!?!!

    // 이유는 반복자의 특성과 벡터의 특성이 잘못 만났기 때문

    // 반복자 : 메모리 정보를 알기 위해서 만든, 벡터 혹은 동적 배열 밑의 클래스

    // 그럼 반복자를 만들었을 때 = 벡터와, 그 순번의 메모리 위치가 등록이 될 것

    // 그런데......

    // 벡터의 경우, 배열처럼 []를 쓸 수 있도록 하기 위해서
    // 내부 구성요소를 고의로 일직선 정렬을 시킨다는 특성이 있다

    // 그리고, 이 상태에서 추가로 구성요소가 더해질 경우....
    // **벡터는 반드시, 혹은 가끔, 자기 자신을 복사한다!!

    // 특히 insert, emplace, erase가 실행되면 벡터의 특성상,
    // 그리고 오류를 막기 위한 c++의 자체 조치로 인해
    // 삽입, 삭제 이전에 할당된 반복자의 값은 무효화된다 (반복자 무효화, iterator invalidation)

    // 그래서 벡터에서 사본이 만들어질 수 있는 함수들
    // (push_back, pop_back, insert, emplace, erase, 아무튼 구성요소가 바뀌는 함수)
    // 이들을 실행한 뒤에는 반드시 반복자의 위치를 다시 지정해줘야 한다

    // 이를 반복자 재지정(재할당)이라고 한다

    // =====================================================================================

    // 반복자에 대한 추가 팁

    // 1. begin과 end의 정확한 위치는 어디인가?

    // -> 구성요소가 기준이 아니다. "벡터라는 클래스 자체가 완전히 시작하고 끝나는 위치"이다.
    // -> 따라서 end();가 호출되었을 경우, 이 위치에서는 읽을 수 있는 구성요소가 없다!

    // 그래서 벡터 vec의 마지막 구성요소를 보고 싶다면 : (vec.end() - 1)을 불러야 한다

    // 2. 왜 이렇게 복잡하고 어렵고 더러운 기능을 벡터에 주었느냐?

    // -> 사실 반복자가 벡터 혼자 쓰려고 만든 게 아니다....
    // -> 동적 배열이 벡터만 있는 것도 아니다....

    // -> 원래는 다른 동적 배열에 쓰려고 만들었다가, 벡터에도 적용이 된 것뿐

    // 3. 그럼, 반복자가 필요할(유용할) 정도의 다른 동적 배열이 또 있는가?

    // -> 벡터 외에 list라는 동적 배열이 게임 개발에서 같이 자주 쓰인다
    // -> deque라는 것도 있다

    // -> 동적 "배열"은 아니지만 pair, map 등 다른 자료를 집합화하는
    //    다른 자료 구조도 많다

    // -> 그리고 이 모두에서 반복자는 일부에서는 유용하다
    //    + 어쨌든 한 클래스에서 반복자를 익히면 다른 클래스에서도 똑같이 쓸 수 있다
}